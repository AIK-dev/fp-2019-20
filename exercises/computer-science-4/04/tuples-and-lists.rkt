#lang racket

; НАРЕДЕНИ ДВОЙКИ
; cons създава наредена 2-ка
(cons 1 #\a)  ; '(1 . #\a)
; Тук точката индикира че това е наредена 2-ка,
; а не списък

; TODO: Ще си поговорим още малко за quote

(define pair '("head" . "tail"))

(pair? pair) ; #t

; Първия елемент (Contents of the Address Register)
(car pair)   ; "hello"

; Втория елемент (Contents of the Data Register)
(cdr pair)   ; "world"


(define deep-list
  '((1 2) ((3 4) 5)))
; има съкратен синтаксис за комбиниране на car и cdr
; caar - първия елемент на първия елемент
; cdar - втория елемент на първия елемент
; и т.н.
(caar deep-list)  ; 1
(cdar deep-list)  ; (2)


; СРАВНЕНИЯ
; (= a b) работи само за числа

; (eq? a b) проверява дали a и b са един и същ обект (на едно и също място в паметта са)

; (eqv? a b) същото като eq? с изключение за някои типове, като char и integer

; (equal? a b) същото като eqv? с изключение за много типове.
; Работи за списъци и и може да сравнява по компонентно.


; СПИСЪЦИ
; 1. '() е списък
; 2. (head . tail) е списък <=> tail е списък

(list 1 2 3 4) ; построява списък от подадените аргументи
; може и с quote
'(1 2 3 4)

'(1 . (2 . (3 . (4 . 5))))  ; '(1 2 3 4 . 5) - наредена 2ка
'(1 . (2 . (3 . (4 . ())))) ; '(1 2 3 4) - списък (и наредена 2-ка)


(pair? '()) ; #f
(null? '()) ; #t
(list? '()) ; #t

; ВГРАДЕНИ ФУНКЦИИ ЗА СПИСЪЦИ:
; (length <list>)- дължина
; (append <list1> ... <listn>) - конкатенация
; (reverse <list>)- връща списък от елементите в обратен ред
; (list-tail <list> n)- връща елементите без последните n
; (list-ref <list> n) - връща n-тия елемент
; (member <element> <list>)- връща опашката на списъка от търсения елемент нататък,
;   #f - ако няма такъв елемент (използва equal?)
; (memv <element> <list>) - като member, но използва eqv?
; (memq <element> <list>) като member, но използва eq?

; ФУНКЦИИ ОТ ПО–ВИСОК РЕД ВЪРХУ СПИСЪЦИ:
; (map <func> <list>) - връща нов списък, където върху всеки елемент е приложена подадената функция
; (filter <pred> <list>) - връща списъка само с елементите, които изпълняват дадения предикат
; (foldr <func> <init> <list>) - акумулира стойност чрез func, започвайки от init и продължавайки
;   прилагането по елементите на list (списъка се обхожда от дясно наляво)
; (foldl <func> <init> <list>) - акумулира стойност чрез func, започвайки от init и продължавайки
;   прилагането по елементипо на list (списъка се обхожда от ляво надясно)
; NOTE: Спомнете си за accumulate
; NOTE: foldr генерира линеен рекурсивен процес, а foldl линеен итеративен

