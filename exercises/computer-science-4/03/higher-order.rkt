#lang racket

; Throwback:
; Последния път говорехме за рекурсия (опашкова) и видове рекурсивни
; процеси.
; Нещо важно: функциите в които всички рекурсивни извиквания са
; опашкови, генерират итеративен рекурсивен процес.

; Функциите са стойност.
; Едно от нещата които можем да правим със стойностите е
; да ги подаваме като аргументи на функции.
; Такава функция, която приема като аргумент друга функция,
; наричаме функция от по-висок ред.

(define plus +)

(define (add2 f x y) (f x y))

(add2 + 2 3) ;5

; Очаква се f да бъде функция и в тялото на binary-op я използваме като такава.
; Тоест прилагаме я върху x и y.
(define (binary-op f x y) (f x y))

(define (add x y) (+ x y))

(define (mult x y) (* x y))

(binary-op add 2 3) ;5
(binary-op mult 2 3) ;6

; Можем и като резултат на една функция да върнем друга.

(define (ifp p g f)
  (if p g f))

(ifp (< 1 2) + *) ;#procedure:+>
; Можем да приложим върнатата функция върху някакви аргументи
((ifp (< 1 2) + *) 5 8) ;13

; Анонимна функция (ламбда)
; (lmbda (<arg1> <arg2> .. <argn>) <body>)
(binary-op (lambda (a b) (/ a b)) 10 2) ;5
; Можем да я конструираме на място вместо да правим отделна дефиниция.

; Можем и да я извикаме веднага след като я дефинираме ако искаме.
((lambda (x y) (gcd x y)) 17 6) ;1

; По същия начин както с именованите функции, ламбда функциите
; можем да ги подаваме като аргументи на други функции или да
; ги връщаме като резултат.

; Важно е че анонимната функция пази указател към средата,
; в която е оценена.

; Няма дефинирано x в момента на извикване на ламбдата.
;((lambda (y) (+ y x)) 2)
;(define x 5)

; Това е ок.
;(define x 5)
;((lambda (y) (+ y x)) 2)
