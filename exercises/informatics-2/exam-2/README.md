Задачи за подготовка за контролно 2
===================================

## 2016

#### Вариант А

**Зад.1** [Scheme или Haskell]
За тази задача ще представяме множествата като списъци от елементи, които могат да
бъдат сравнявани с предикати за равенство и за наредба (т.е. `==` и `<` в Haskell, `equal?` и `<` в
Scheme).
Елементите в тези списъци не могат да се повтарят и трябва да са в строго нарастващ
ред.

Да се реализират основните операции над множества: **обединение**, **сечение**, **разлика** и
**симетрична разлика** така, че резултатът на операциите отново да са множества, представени
като **сортирани в нарастващ ред списъци**.

Примери:

```haskell
setUnion [1,2,3,4,5] [2,3,5,6] → [1,2,3,4,5,6] -- а не [1,2,3,3,4,5,5,6],
-- нито [1,2,3,4,5,2,3,5,6]

setIntersect [1,2,3,4,5] [2,3,5,6] → [2,3,5]
setDiff [1,2,3,4,5] [2,3,5,6] → [1,4]
setDiff [2,3,5,6] [1,2,3,4,5] → [6]
setSymDiff [1,2,3,4,5] [2,3,5,6] → [1,4,6]
```

**Забранена е употребата на вградени функции, които извършват същите операции!**

**Зад.2** [Scheme или Haskell]
Да се напише функция, която приема като параметър списък от списъци и го сортира по
честотата, с която се срещат дължините на вътрешните списъци.

Пример:

`lfsort ["abc", "de", "fgh", "fp", "ijkl", "mn", "o"]
→ ["ijkl", "o", "abc", "fgh", "fp", "de", "mn"]`

- има един списък с дължина 4

- един списък с дължина 1

- два списъка с дължина 3

- и три списъка с дължина 2.

Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е.
техните дължини се срещат еднакъв брой пъти – няма значение.

Упътване: можете да напишете и използвате помощна функция `histogram`, която
приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов
елемент и броя срещания в списъка:

```haskell
histogram [1,2,2,3,4,2,1,2] → [(1,2), (2,4), (3,1), (4,1)]
```

**Зад.3.** [Haskell]
Нека имаме дефиниран `type Item = (String, Integer)` – информация за артикул с
име и оставащ срок на годност в дни. Ако срокът на годност е отрицателното число x, значи този
артикул е изтекъл преди **|x|** дни.

Да се напише функция със сигнатура
`expiringItems :: [Item] → (String, Integer, String)`, която по списък с такива данни
връща наредена тройка от името на артикула с най-кратък оставащ срок на годност (без да се
броят тези, чиито срок е изтекъл), броят артикули с изтекъл срок на годност и името на артикула
с най-отдавна изтекъл срок на годност:

```haskell
expiringItems [("Milk",3), ("Bread",1), ("Yoghurt",-3),
("Butter",5), ("Cheese",-1), ("Pasta",2)]

→ ("Bread", 2, "Yoghurt") -- два негодни артикула: "Yoghurt" и "Cheese", като от тях "Yoghurt" е с по-отдавна изтекъл срок.

```

**Зад.4.** [Scheme]
Да се напише функция `prune`, която по дадено двоично дърво **t** връща ново дърво **t'**,
което представлява **t**, в което всички листа са премахнати.

#### Вариант Б

**Зад.1** [Scheme или Haskell]
За тази задача ще представяме мултимножествата като списъци от елементи, които могат
да бъдат сравнявани с предикати за равенство и за наредба (т.е. `==` и `<` в Haskell, `equal?` и `<` в
Scheme). Елементите в тези списъци могат да се повтарят и трябва да са в монотонно нарастващ
ред. Да се реализират основните операции над мултимножества: обединение, сечение и сума
така, че резултатът на операции отново да са мултимножества, представени като сортирани в
монотонно нарастващ ред списъци. Ако даден елемент x се среща в мултимножествата A и B
съответно a и b на брой пъти, то:

- в A ∪ B трябва да се среща max(a,b) пъти

- в A ∩ B трябва да се среща min(a,b) пъти

- в A + B трябва се среща a+b пъти

```haskell
multisetUnion [1,2,2,3,3,4,5] [2,3,3,3,5,6] → [1,2,2,3,3,3,4,5,6]
multisetIntersect [1,2,2,3,3,4,5] [2,3,3,3,5,6] → [1,2,3,3,5]
multisetSum [1,2,2,3,3,4,5] [2,3,3,3,5,6] → [1,2,2,2,3,3,3,3,3,4,5,5,6]
```

**Забранена е употребата на вградени функции, които извършват същите операции!**

**Зад.2** [Scheme или Haskell]
Да се напише функция, която приема като параметър списък от списъци и го сортира
относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, се избира най-големия от тях:

```haskell
hlsort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
→ ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
```

В този пример най-често
срещаните елементи са 'a', 'e', 'e', 'g', 'm', 'o' и 'z'.

Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е. най-
често срещаните елементи в тях са едни и същи –няма значение.

Упътване: можете да напишете и използвате помощна функция histogram, която
приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов
елемент и броя срещания в списъка:

```haskell
histogram [1,2,2,3,4,2,1,2] → [(1,2), (2,4), (3,1), (4,1)]
```

**Зад.3.** [Haskell]
Нека имаме дефиниран `type Quote = (String, Double)` – информация за цена на
акция на компания с дадено име. Да се напише функция със сигнатура
`bestCompany :: [Quote] → (String, Double, Double)`, която по списък от такива данни
връща наредена тройка от името на компанията с най-висока средна стойност на всички нейни
акции, както и най-ниската и най-високата стойност на нейните акции:

```haskell
bestCompany [("Acme",2.56), ("Buy'n'Large",12.5), ("Acme",42), ("Smiths",9.8),

("Buy'n'Large",13.37), ("Acme",10.4), ("Smiths",10.6)]

→ ("Acme", 2.56, 42)
```

**Зад.4.** [Scheme]
Да се напише функция `bloom`, която по дадено двоично дърво **t** връща ново дърво **t'**,
което представлява **t**, в което на всички листа са добавени по два наследника - нови листа.
Стойността в тези нови листа да е същата, като в оригиналното листо, от което са излезли.
