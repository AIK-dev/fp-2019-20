Задачи за подготовка за контролно 2
===================================

## 2016

#### Вариант А

**Зад.1** [Scheme или Haskell]
За тази задача ще представяме множествата като списъци от елементи, които могат да
бъдат сравнявани с предикати за равенство и за наредба (т.е. `==` и `<` в Haskell, `equal?` и `<` в
Scheme).
Елементите в тези списъци не могат да се повтарят и трябва да са в строго нарастващ
ред.

Да се реализират основните операции над множества: **обединение**, **сечение**, **разлика** и
**симетрична разлика** така, че резултатът на операциите отново да са множества, представени
като **сортирани в нарастващ ред списъци**.

Примери:

```haskell
setUnion [1,2,3,4,5] [2,3,5,6] → [1,2,3,4,5,6] -- а не [1,2,3,3,4,5,5,6],
-- нито [1,2,3,4,5,2,3,5,6]

setIntersect [1,2,3,4,5] [2,3,5,6] → [2,3,5]
setDiff [1,2,3,4,5] [2,3,5,6] → [1,4]
setDiff [2,3,5,6] [1,2,3,4,5] → [6]
setSymDiff [1,2,3,4,5] [2,3,5,6] → [1,4,6]
```

**Забранена е употребата на вградени функции, които извършват същите операции!**

**Зад.2** [Scheme или Haskell]
Да се напише функция, която приема като параметър списък от списъци и го сортира по
честотата, с която се срещат дължините на вътрешните списъци.

Пример:

`lfsort ["abc", "de", "fgh", "fp", "ijkl", "mn", "o"]
→ ["ijkl", "o", "abc", "fgh", "fp", "de", "mn"]`

- има един списък с дължина 4

- един списък с дължина 1

- два списъка с дължина 3

- и три списъка с дължина 2.

Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е.
техните дължини се срещат еднакъв брой пъти – няма значение.

Упътване: можете да напишете и използвате помощна функция `histogram`, която
приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов
елемент и броя срещания в списъка:

```haskell
histogram [1,2,2,3,4,2,1,2] → [(1,2), (2,4), (3,1), (4,1)]
```

**Зад.3.** [Haskell]
Нека имаме дефиниран `type Item = (String, Integer)` – информация за артикул с
име и оставащ срок на годност в дни. Ако срокът на годност е отрицателното число x, значи този
артикул е изтекъл преди **|x|** дни.

Да се напише функция със сигнатура
`expiringItems :: [Item] → (String, Integer, String)`, която по списък с такива данни
връща наредена тройка от името на артикула с най-кратък оставащ срок на годност (без да се
броят тези, чиито срок е изтекъл), броят артикули с изтекъл срок на годност и името на артикула
с най-отдавна изтекъл срок на годност:

```haskell
expiringItems [("Milk",3), ("Bread",1), ("Yoghurt",-3),
("Butter",5), ("Cheese",-1), ("Pasta",2)]

→ ("Bread", 2, "Yoghurt") -- два негодни артикула: "Yoghurt" и "Cheese", като от тях "Yoghurt" е с по-отдавна изтекъл срок.

```

**Зад.4.** [Scheme]
Да се напише функция prune, която по дадено двоично дърво t връща ново дърво t',
което представлява t, в което всички листа са премахнати.
