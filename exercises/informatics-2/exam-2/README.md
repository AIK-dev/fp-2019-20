Задачи за подготовка за контролно 2
===================================

## 2016

#### Вариант А

**Зад.1 [Scheme или Haskell]**
За тази задача ще представяме множествата като списъци от елементи, които могат да
бъдат сравнявани с предикати за равенство и за наредба (т.е. `==` и `<` в Haskell, `equal?` и `<` в
Scheme).
Елементите в тези списъци не могат да се повтарят и трябва да са в строго нарастващ
ред.

Да се реализират основните операции над множества: **обединение**, **сечение**, **разлика** и
**симетрична разлика** така, че резултатът на операциите отново да са множества, представени
като **сортирани в нарастващ ред списъци**.

Примери:

```haskell
setUnion [1,2,3,4,5] [2,3,5,6] → [1,2,3,4,5,6] -- а не [1,2,3,3,4,5,5,6],
-- нито [1,2,3,4,5,2,3,5,6]

setIntersect [1,2,3,4,5] [2,3,5,6] → [2,3,5]
setDiff [1,2,3,4,5] [2,3,5,6] → [1,4]
setDiff [2,3,5,6] [1,2,3,4,5] → [6]
setSymDiff [1,2,3,4,5] [2,3,5,6] → [1,4,6]
```

**Забранена е употребата на вградени функции, които извършват същите операции!**

**Зад.2 [Scheme или Haskell]**
Да се напише функция, която приема като параметър списък от списъци и го сортира по
честотата, с която се срещат дължините на вътрешните списъци.

Пример:

`lfsort ["abc", "de", "fgh", "fp", "ijkl", "mn", "o"]
→ ["ijkl", "o", "abc", "fgh", "fp", "de", "mn"]`

- има един списък с дължина 4

- един списък с дължина 1

- два списъка с дължина 3

- и три списъка с дължина 2.

Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е.
техните дължини се срещат еднакъв брой пъти – няма значение.

Упътване: можете да напишете и използвате помощна функция `histogram`, която
приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов
елемент и броя срещания в списъка:

```haskell
histogram [1,2,2,3,4,2,1,2] → [(1,2), (2,4), (3,1), (4,1)]
```

**Зад.3. [Haskell]**
Нека имаме дефиниран `type Item = (String, Integer)` – информация за артикул с
име и оставащ срок на годност в дни. Ако срокът на годност е отрицателното число x, значи този
артикул е изтекъл преди **|x|** дни.

Да се напише функция със сигнатура
`expiringItems :: [Item] → (String, Integer, String)`, която по списък с такива данни
връща наредена тройка от името на артикула с най-кратък оставащ срок на годност (без да се
броят тези, чиито срок е изтекъл), броят артикули с изтекъл срок на годност и името на артикула
с най-отдавна изтекъл срок на годност:

```haskell
expiringItems [("Milk",3), ("Bread",1), ("Yoghurt",-3),
("Butter",5), ("Cheese",-1), ("Pasta",2)]

→ ("Bread", 2, "Yoghurt") -- два негодни артикула: "Yoghurt" и "Cheese", като от тях "Yoghurt" е с по-отдавна изтекъл срок.

```

**Зад.4. [Scheme]**
Да се напише функция `prune`, която по дадено двоично дърво **t** връща ново дърво **t'**,
което представлява **t**, в което всички листа са премахнати.

#### Вариант Б

**Зад.1 [Scheme или Haskell]**
За тази задача ще представяме мултимножествата като списъци от елементи, които могат
да бъдат сравнявани с предикати за равенство и за наредба (т.е. `==` и `<` в Haskell, `equal?` и `<` в
Scheme). Елементите в тези списъци могат да се повтарят и трябва да са в монотонно нарастващ
ред. Да се реализират основните операции над мултимножества: обединение, сечение и сума
така, че резултатът на операции отново да са мултимножества, представени като сортирани в
монотонно нарастващ ред списъци. Ако даден елемент x се среща в мултимножествата A и B
съответно a и b на брой пъти, то:

- в A ∪ B трябва да се среща max(a,b) пъти

- в A ∩ B трябва да се среща min(a,b) пъти

- в A + B трябва се среща a+b пъти

```haskell
multisetUnion [1,2,2,3,3,4,5] [2,3,3,3,5,6] → [1,2,2,3,3,3,4,5,6]
multisetIntersect [1,2,2,3,3,4,5] [2,3,3,3,5,6] → [1,2,3,3,5]
multisetSum [1,2,2,3,3,4,5] [2,3,3,3,5,6] → [1,2,2,2,3,3,3,3,3,4,5,5,6]
```

**Забранена е употребата на вградени функции, които извършват същите операции!**

**Зад.2 [Scheme или Haskell]**
Да се напише функция, която приема като параметър списък от списъци и го сортира
относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, се избира най-големия от тях:

```haskell
hlsort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
→ ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
```

В този пример най-често
срещаните елементи са 'a', 'e', 'e', 'g', 'm', 'o' и 'z'.

Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е. най-
често срещаните елементи в тях са едни и същи –няма значение.

Упътване: можете да напишете и използвате помощна функция histogram, която
приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов
елемент и броя срещания в списъка:

```haskell
histogram [1,2,2,3,4,2,1,2] → [(1,2), (2,4), (3,1), (4,1)]
```

**Зад.3. [Haskell]**
Нека имаме дефиниран `type Quote = (String, Double)` – информация за цена на
акция на компания с дадено име. Да се напише функция със сигнатура
`bestCompany :: [Quote] → (String, Double, Double)`, която по списък от такива данни
връща наредена тройка от името на компанията с най-висока средна стойност на всички нейни
акции, както и най-ниската и най-високата стойност на нейните акции:

```haskell
bestCompany [("Acme",2.56), ("Buy'n'Large",12.5), ("Acme",42), ("Smiths",9.8),

("Buy'n'Large",13.37), ("Acme",10.4), ("Smiths",10.6)]

→ ("Acme", 2.56, 42)
```

**Зад.4. [Scheme]**
Да се напише функция `bloom`, която по дадено двоично дърво **t** връща ново дърво **t'**,
което представлява **t**, в което на всички листа са добавени по два наследника - нови листа.
Стойността в тези нови листа да е същата, като в оригиналното листо, от което са излезли.

## 2017

#### Вариант А

**Задача 1 (8 т.) [Scheme/Haskell]**
Нека е даден списък от наредени двойки от числа, представляващи точки в равнината. Да се напише функция `findMedoid`, която намира такава точка от списъка, за която сумата от квадратите на разстоянията до всички останали точки в списъка е минимална.

Пример:

```haskell
findMedoid [(2,8),(-2,4),(1,2),(-4,-1),(5,0)] → (1,2)
```

**Задача 2 (8 т.) [Scheme/Haskell]**
Да се напише функция `sumLast`, която приема две положителни естествени числа `k` и `n` и генерира безкрайния поток, в който първото число е k, а всяко следващо число е равно на сумата от предходните `n` числа в потока.

Пример:

```haskell
sumLast 3 5 → [3, 3, 6, 12, 24, 48, 93, 183, ... ]
```

**Задача 3 (8 т.) [Scheme/Haskell]**
Нека е даден ориентиран граф със символи по върховете и целочислени тегла по върховете, който е представен чрез списъци от наследници по следния начин:

Scheme:

```scheme
(define G ‘((a 2 b c)))
            (b 4 a c)))
            (c 1 a b))))
```

Haskell:

```haskell
g :: [(Char,Int,[Char])]
g = [('a', 2, "bc"]),
     ('b', 4, "ac"),
     ('c', 1, "ab")]
```

Да се напише функция `eulerCycleCost`, която проверява дали графът съдържа Ойлеров цикъл и ако да, връща цената му (сборът от теглата на върховете, през които минава). Ако Ойлеров цикъл няма, да се върне 0.

**Задача 4 (8 т.) [Scheme]** Да се напише функция `transformSum`, която преобразува дърво с елементи цели числа в ново дърво със същата структура, в което всеки елемент е заменен със сумата на елементите в поддървото с този корен в началното дърво.

**Бонус (4 т.):** `transformSum` да работи за време **O(n)** в най-лошия случай.

#### Вариант Б

**Задача 1 (8 т.) [Scheme/Haskell]** Нека е даден списък от наредени двойки от числа, представляващи точки в равнината. Да се напише функция `findPoint`, която намира такава точка от списъка, за която сумата от квадратите на разстоянията до всички останали точки в списъка е максимална.
Пример:

```haskell
findPoint [(2,8),(-2,4),(1,2),(-4,-1),(5,0)] → (-4,-1)
```

**Задача 2 (8 т.) [Scheme/Haskell]** Да се напише функция `multLast`, която приема две положителни естествени числа `k` и `n` и генерира безкрайния поток, в който първото число е `k`, а всяко следващо число е произведението от предходните `n` числа в потока.

Пример:

```haskell
multLast 2 3 → [2, 4, 8, 64, 2048, ... ]
```

**Задача 3 (8 т.) [Scheme/Haskell]** Нека е даден ориентиран граф със символи по върховете и целочислени тегла по върховете, който е представен чрез списъци от наследници по следния начин:

Scheme:

```scheme
(define G ‘((a 2 b c)))
            (b 4 a c)))
            (c 1 a b))))
```

Haskell:

```haskell
g :: [(Char, Int, [Char])]
g = [('a', 2, "bc"]),
     ('b', 4, "ac"),
     ('c', 1, "ab")]
```

Да се напише функция `eulerPathCost`, която проверява дали графът съдържа Ойлеров път, който не е цикъл, и ако да, връща цената му (сборът от теглата на върховете, през които минава), а ако не, връща 0.

**Задача 4 (8 т.) [Scheme]** Да се напише функция `transformCount`, която преобразува дърво с елементи цели числа в ново дърво със същата структура, в което всеки елемент е заменен с броя на елементите в поддървото с този корен в началното дърво.

**Бонус (4 т.):** `transformCount` да работи в **O(n)** време в най-лошия случай.
