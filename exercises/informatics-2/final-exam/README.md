Задачи за подготовка за изпит
=============================

## 2016

#### Вариант А

**Задача 1. (10 т.)** Да се напише функция findColumns, която по дадена матрица от числа намира броя на колоните, за които е вярно, че всичките им елементи се срещат в някой от редовете на матрицата.

Пример:

```haskell
findColumns [[1,4,3],[4,5,6],[7,4,9]] → 1
```

**Задача 2. (15 т.)** Ако f и g са унарни числови функции, а h е бинарна числова функция, то дефинираме функцията f{h}g по следния начин: (f{h}g) (x) := h(f(x),g(x)). Дадени са две цели числа a < b и два списъка uns и bins, съответно с унарни и бинарни функции. Да се напише функция check, която проверява дали има такива функции f и g от списъка uns и h от списъка bins така, че f{h}g да съвпада с някоя от функциите в uns върху всички цели числа в интервала [a;b].
Упътване: използвайте помощна функция от по-висок ред combine, която по дадени f, g и h връща така дефинираната f{h}g.

Пример:

```haskell
check 1 9 [(+1),(-1),(-1).(^2)] [(*)] → True
```

**Задача 3. (15 т.)** Растение се описва с наредена тройка от име (низ), минимална и максимална температура, в която вирее (цели числа градуси). Да се напише функция garden, която по списък от растения намира интервал от стойности на температура, в който максимален брой растения могат да виреят, заедно с имената на тези растения.

Пример:

```haskell
garden[("peas",5,25),("beans",3,15),("cocoa",20,30)] → ((20,25),["peas","cocoa"])
```

**Задача 4. (15 т.)** Даден е граф g, представен със списък от наследници и връх u в графа. Да се напише функция maxPath, която намира най-дългия ацикличен път в g, започващ от върха u.

Пример:

```haskell
maxPath [[1,2,4],[2,3],[3,2],[4]] 1 → [1,2,3]
```

#### Вариант Б

**Задача 1. (10 т.)** Да се напише функция hasColumn, която по дадена матрица от числа проверява има ли в нея колона, в която всяко число се среща във всеки един от редовете на матрицата.

Пример:

```haskell
hasColumn [[1,2,3],[2,3,4],[5,3,2]] → True
```

**Задача 2. (15 т.)** Ако f и g са бинарни числови функции, а h е унарна числова функция, то дефинираме функцията f—g→h по следния начин: (f—g→h) (x) := f(x,g(x,h(x)). Дадени са две цели числа a < b и два списъка uns и bins, съответно с унарни и бинарни функции. Да се напише функция check, която проверява дали има такива функции f и g от списъка bins и h от списъка uns така, че f—g→h да съвпада с някоя от функциите в uns върху всички цели числа в интервала [a;b].
Упътване: използвайте помощна функция от по-висок ред combine, която по дадени f, g и h връща така дефинираната f—g→h.

Пример:

```haskell
check 1 9 [(+2),(-2)] [(+),(-)] → True
```

**Задача 3. (15 т.)** Спектакъл се описва с наредена тройка от име (низ), начален кръгъл час (от 0 до 23) и брой минути, които продължава (от 1 до 300). Да се напише функция showtime която по списък от спектакли в един и същ ден намира в кой едночасов интервал протичат максимален брой спектакли, колко минути продължава засичането и кои са имената засичащите се спектакли.

Пример:

```haskell
showtime [("Cats",21,130),("Rent",19,100), ("Hair",22,90)] → ((22,70),["Cats","Hair"])
```

**Задача 4. (15 т.)** Даден е граф g, представен със списък от наследници. Да се напише функция maxCycle намери най-дългият прост цикъл в g, включващ даден връх u. Упътване: прост цикъл наричаме път в който само първият и последният връх съвпадат.

Пример:

```haskell
maxCycle [[1,2],[2,3],[3,1,4],[4,2]] 1 → [1,2,3,1]
```

## 2017

#### Вариант А

**Задача 1 (12 т.).** Да се напише функция largestInterval, която получава като аргументи две едноместни целочислени функции f и g и две цели числа a и b. Функцията трябва да намира най-големия целочислен подинтервал на [a, b] такъв, че двете функции дават еднакви стойности за всяко цяло число в него.

Пример:

```haskell
largestInterval (\x -> x) (\x -> x*x) 0 3 -> (0, 1)
```

**Задача 2. (16 т.)** Да се напише функция intervalTree, която преобразува двоично дърво от числа в ново дърво със същата структура, в което стойността във всеки възел е заменена с наредена двойка, представляваща най-малкия интервал, съдържащ всички стойности в съответното поддърво. Представянето на дървото е по

Пример:
![example](images/image1.png)


**Бонус (4 т.):** intervalTree да работи за време O(n) в най-лошия случай.

**Задача 3. (10 т.)** Да се генерира поток sumsOfSquares от тези числа, които са сума от квадратите на две положителни цели числа.

**Задача 4. (12 т.)** Видеоклип се представя с име (низ) и дължина (брой секунди). Да се напише функция averageVideo, която по непразен списък от видеоклипове намира името на този, който е с дължина най-близка до средната дължина на всички видеоклипове в списъка, без да я надхвърля.

Пример:

```haskell
averageVideo [("lolcat", 15), ("dogewow", 35), ("omgseethis", 28)] → "lolcat"
```

#### Вариант Б

**Задача 1. (12 т.)** Да се напише функция countIntervals, която получава като аргументи две едноместни целочислени функции f и g и две цели числа a и b. Функцията трябва да намира броя на всички непразни целочислени подинтервали на [a, b], в които да няма цяло число, за което функциите да дават еднакви стойности.

Пример:

```haskell
countIntervals (\x -> x) (\x -> x*x) 0 3 -> 3
```

Интервалите са [2, 2], [2, 3] и [3, 3].

**Задача 2. (16 т.)** Да се напише функция pairTree, която преобразува двоично дърво от числа в ново дърво със същата структура, в което стойността във всеки възел е заменена с наредена двойка, представляваща най-малката стойност в лявото поддърво на съответния възел (включително и самия възел) и най-голямата стойност в дясното поддърво на съответния възел (включително и самия възел).

Пример:
![example](images/image1.png)

**Бонус (4 т.):** pairTree да работи за време O(n) в най-лошия случай.

**Задача 3. (10 т.)** Да се генерира поток sumsOfCubes от тези числа, които са сума от кубовете на две положителни цели числа.

**Задача 4. (12 т.)** Чифт обувки се представят с модел (низ) и номер (цяло число). Да се напише функция bestRange, която по даден непразен списък от чифтове намира модел обувки, от който има максимален брой различни номера.

Пример:

```haskell
bestRange [("boots", 38), ("sandals", 41), ("boots", 38), ("sandals", 43)] → "sandals"
```
