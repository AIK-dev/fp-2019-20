Задачи за подготовка за Контролно 1
===================================

1. `[lists]` Нека `А` и `B` са множества, представени чрез списъци. Да се имплементират следните функции над множествата `А` и `B`:
    - сечение
    - обединение
    - разлика

1. `[HOFs, lists]` Напишете функция от по-висок ред, която по дадена едноместна числова функция `f` и списък от числа `l` намира списък от всички числа `x` в `l`, за които `f(x)` е елемент на `l`.

1. `[digits, recursion, iteration]` Да се напише функция `middle-digit`, която намира средната цифра от записа на подадено естествено число `n`. Ако `n` е с четен брой цифри, функцията връща `-1`.

    Пример: `(middle-digit 452)` → `5`

    Пример: `(middle-digit 4712)` → `-1`

1. `[matrices]` Да се напише функция count-cols, която приема матрица от числа и намира броя на колоните, в които има поне едно число, което съвпада със сумата на останалите числа в колоната.

    Пример: `(count-cols '((1 2 3 6) (2 3 4 2) (3 4 5 4)))` → `2`

1. `[matrices]` Да се напише функция `two-rows?`, която приема матрица от числа и проверява дали в нея има два реда, такива че всички числа от първия ред са по-малки от всички числа във втория ред.

    Пример: `(two-rows? '((1 2 3) (2 3 4) (3 4 5) (6 5 4)))` → `#t`

1. `[HOFs, lists]` Нека е даден списък l от числа и двуместна операция над числа ⊕. Функцията f наричаме “ендоморфизъм над l”, ако f трансформира l в себе си, запазвайки операцията ⊕, т.е. `∀x∈l f(x)∈l` и `∀x,y∈l f(x) ⊕ f(y) = f(x ⊕ y)`. Да се реализира функция `is-em?`, която проверява дали `f` е ендоморфизъм.

    Пример: `(is-em? '(0 1 4 6) + (lambda (x) (remainder x 3)))` → `#t`

1. `[HOFs, lists]` Нека са дадени два списъка от числа `l1` и `l2`.
Функцията `f` наричаме *"сюрекция от l1 в l2"*, ако:
    - `f` трансформира `l1` в `l2`:  `∀x∈l₁ f(x)∈l₂`
    - `f` покрива изцяло `l2`: `∀y∈l₂ ∃x∈l₁ f(x)=y`

    Да се напише функция `is-sur?`, която проверява дали `f` е сюрекция.

    Пример: `(is-sur? '(0 1 -1 2) '(0 1 4) square)` → `#t`

1. `[trees]` В дадено двоично дърво "семейство" наричаме даден възел заедно с неговите деца. Казваме, че две семейства "си приличат", ако съвпадат по структура и стойности на съответните им възли. Да се напише функция `families-alike?`, която проверява дали в дадено двоично дърво има приличащи си семейства.

1. `[trees]` В дадено двоично дърво казваме, че два възела са "братовчеди", ако общият родител на двамата е поне две нива над тях. Да се напише функция "cousins", която по дадено двоично дърво от различни числа и възел `u` в него намира броя на всички братовчеди на `u`. Представянето на дървото е по ваш избор.

1. `[graphs]` Да се напише функция `(chinese? g)`, която за даден граф g
проверява дали за него е изпълнен китайският закон: *"даден възел може да има повече от един наследник само ако е той е единствен наследник на родителя си"*.
