## Магии.
#### Да си дефинираме инфиксна аритметика
"Аритметична операция" наричаме символ, който е измежду `+ - * /`.

1. Напишете функция `(oper? x)`, която проверява дали `x` е аритметична операция.

"Инфиксна форма" наричаме списък с 3 елемента, от които вторият е аритметична операция.

2. Напишете функция `(infix-form? x)`, която проверява дали `x` е инфиксна форма.

3. Напишете функция `(infix x)`, която:

- ако `x` е инфиксна форма, въща резултатът от прилагане на операцията върху операндите.
- в противен случай, връща `x`.

Примери:
- `(infix 42) -> 42`
- `(infix '(1 + 3)) -> 4`
- `(infix '((1 + 1) + (3 + 5))) -> 10`

4. *Демонстрация:* ограниченията на този модел и как може да го подобрим
5. Напишете функция `(infixify x)`, която:

- ако `x` е инфиксна форма, въща префиксна форма със същата семантика
- в противен случай, връща `x`.

Примери:
- `(infixify 42) -> 42`
- `(infixify '(1 + 3)) -> '(+ 1 3)`
- `(infixify '((1 + 1) + (3 + 5))) -> '(+ (+ 1 1) (+ 3 5))`

6. *Демонстрация:* defmacro
7. *Демонстрация:* quasiquote
7. *Демонстрация:* syntax-rules

#### Потоци
1. *Демонстрация:* дефиниране на поток

Дефинирайте следните потоци (като константи):
2. `nats` - редицата от всички естествени числа (`0, 1, 2, 3, 4, ...`)
3. `pow2` - редицата от всички степени на двойката (`1, 2, 4, 8, 16, ...`)
3. `fibs` - редицата от всички числа на Фибоначи (`1, 1, 2, 3, 5, ...`)

Дефинирайте следните функции, работещи върху потоци:
5. `(stream-take n s)`, която връща списък от първите `n` елемента в потока `s`
6. `(stream-from-list l)`, която връща поток с елементи - елементите на списъка `l`
7. `(stream-map f s)`, която връща нов поток, чиито елементи са резултатите
от прилагането на `f` върху елементите на `s`
8. `(stream-filter p? s)`, която връща нов поток, чиито елементи са елементите от
`s`, за които `p?` връща `#t`
9. `(stream-zip s1 s2)`, която връща нов поток, чиито елементи са двойки от елементи,
взети съответно от `s1` и `s2`

