## Задачи:
#### Списъци:
Дефинирайте следните функции работещи върху списъци:

1. `(len l)`, която намира дължината на списък
1. `(exists? l p)`, която проверява дали съществува елемент в `l`, за който
е изпълнен предикатът `p`.
1. `(member? l x)`, която проверява дали елементът `x` се съдържа в списъка `l`
(какво значи "съдържа"?)
1. `(at n x)`, която връща елементът, намиращ се на позиция `n` (броим от 0)
в списъка или `null`, ако позицията е извън списъка
1. `(map f l)`, която прилага `f` върху всеки елемент на списъка `l`
1. `(filter p l)`, която съставя нов списък, съдържащ само елементите на `l`,
за които е изпълнен предикатът `p`
1. `(reverse l)`, която връща списък с елементите на `l` в обратен ред
1. `(push x l)`, която добавя елемента `x` на края на списъка `l`
1. `(insert x n l)`, която вкарва елемента `x` на позиция `n` в списъка `l`
(ако `n` е след края на `l`, вкарваме `x` накрая)
1. `(accumulate l op init)`, която пресмята `(op l[0] (op l[1] (op l[2] ... (op l[n] init) ... )))`
(ако имаме подаден празен списък, резултатът е `init`).
1. `(sum l)`, която намира сумата на елементите в списък

#### Матрици:
Дефинирайте следните функции:
1. `(at m i j)`, която връща елементът на позиция `i, j` в матрицата `m`.

Пример: `(at '((1 2 3) (4 5 6) (7 8 9)) 2 1) -> 6`

2. `(mat-map f m)`, която прилага функцията f върху всеки елемент на матрицата
`m`.

Пример: `(mat-map (lambda (x) (+ 1 x)) '((1 2 3) (4 5 6) (7 8 9))) -> ((2 3 4) (5 6 7) (8 9 10))`

3. `(scalmul x m)`, която умножава всеки елемент на матрицата `m` с числото `x`:

Пример: `(scalmul 2 '((1 2 3) (4 5 6) (7 8 9))) -> ((2 4 6) (8 10 12) (14 16 18))`

4. `(transpose m)`, която транспонира матрицата `m`:

Пример: `(transpose '((1 2 3) (4 5 6) (7 8 9))) -> ((1 4 7) (2 5 8) (3 6 9))`

5. `(matmul m n)`, която умножава матриците m и n:

Пример: `(matmul '((1 2 3) (4 5 6)) '((7 8) (9 10) (11 12))) -> ((58 64) (139 154))`

#### Асоциативен списък:
"Асоциативен списък" ще наричаме списък от двойки, в които левият елемент е
уникален (и го наричаме ключ), а десният наричаме стойност.

Дефинирайте:
1. Константата `assoc-empty`, която съответства на празен асоциативен списък
2. Предикатът `(assoc? l)`, който проверява дали `l` е валиден асоциативен
списък
3. Функцията `(assoc-set l k v)`, която връща нов асоциативен списък, който
представлява `l` с добавена двойка с ключ `k` и стойност `v`.

Примери:
- `(assoc-set '((foo . 1) (bar . 2)) 'qux 3) -> ((foo . 1) (bar . 2) (qux . 3))`
- `(assoc-set '((foo . 1) (bar . 2)) 'foo 3) -> ((foo . 3) (bar . 2))`

4. Функцията `(assoc-get l k)`, която по даден ключ връща стойността, асоциирана
с него (ако такъв ключ не съществува, връща `#f`)
5. Функцията `(assoc-map f l)`, която връща нов асоциативен списък, който
е резултатът от прилагането на `f` върху стойностите в `l`.
6. Функцията `(assoc-filter p l)`, която връща нов асоциативен списък, който
съдържа само двойките, за чиято стойност `p` връща "истина"
7. Функцията `(assoc-merge l1 l2)`, която връща нов асоциативен списък, за който:
- множеството от ключове е обединението на ключовете на `l1` и `l2`
- ако `(k . v)` се среща в `l2`, то `(k . v)` се среща в резултата
- иначе, ако `(k . v)` се среща в `l1`, то `(k . v)` се среща в резултата

#### Насочен граф:
Представяме "насочен граф", като асоциативен списък, в който ключовете са
върховете, а стойностите са списъци от съседите на дадения връх.

Напишете следните функции:

1. `(graph? g)`, която проверява дали `g` е валиден насочен граф по горното описание
2. `(out-deg g x)`, която връща броя излизащи ребра от `x`
3. `(in-deg g x)`, която връща броя влизащи ребра в `x`
4. `(deg g x)`, която връща броят ребра, влизащи в или излизащи от `x`
5. `(max-deg g)`, която връща максималният брой влизащи/излизащи ребра
от връх
6. `(path g x y)`, която връща някой път в `g`, започващ в `x` и завършващ в
`y`. Ако няма такъв път, връща `#f`.
7. `(shortest-path g x y)`, която връща най-кратък път в `g`, започващ в `x` и завършващ в
`y`. Ако няма такъв път, връща `#f`.
