#### Haskell / списъци
Ще демонстрираме/преговорим следните неща:

- undefined
- оператори
- списъци
- lambda
- tuple
- map, filter, foldl, foldr

#### Задачи
Дефинирайте прости рекурсивни варианти на следните функции от
модула (http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html)[Prelude]:

1. `elem' :: (Eq a) => a -> [a] -> Bool`, която проверява дали елемент присъства в списък
2. `reverse' :: [a] -> [a]`, която обръща списък
3. `map' :: (a -> b) -> [a] -> [b]`, която прилага функция върху всички елементи на списък
4. `filter' :: (a -> Bool) -> [a] -> [a]`, която филтрира списък спрямо предикат
5. `zip' :: [a] -> [b] -> [(a, b)]`, която връща списък от двойки с първи елементи елементите на първия списък, и втори елементи - елементите на втория списък
6. `uncurry' :: (a -> b -> c) -> (a, b) -> c`, която превръща функция на два аргумента във функция на един аргумент, който е двойка
7. `zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]`, която връща списък, получен от викане на дадената функция върху поредни елементи от първия и втория списък. Използвайте `zip'` и `uncurry'`.

Дефинирайте следните функции, работещи с множества (списъци без повторения на елементите) и напишете техните типове:

8. `unite m n`, която връща множество, съдържащо елементите, които са в множествата `m` или `n`
9. `product m n`, която връща списък от всички възможни двойки с първи елемент от `m` и втори елемент `n`
10. `intersect m n`, която връща множество, съдържащо елементите, които са едновременно в множествата `m` и `n`. С какво тази функция е по-сложна от предните две?

Демонстрация: list comprehension

11. Дефинирайте функция `mySort :: (Ord a) => [a] -> [a]`, която сортира списък. (hint: quicksort и merge sort се пишат лесно!)
12. Дефинирайте функция `permutations :: [a] -> [[a]]`, която намира всички пермутации на списък

