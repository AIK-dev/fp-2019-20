## Haskell
- Типизиран (много силно)
- Чисто функционален
- Компилиран
- От светлата страна на програмирането

## Скучни задачи (аритметика)
Да напишем заедно следните функции:

1. `fact :: Int -> Int`, такава че `factorial n` връща n!
2. `fib :: Int -> Int`, такава че `fib n` връща n-тото число на Фибоначи
3. `isPrime :: Int -> Bool`, която проверява дали число е просто
4. `gcd' :: Int -> Int -> Int`, която намира най-големият общ делител на 2 числа

## Не толкова скучни задачи
5. Дефинирайте тип `IntList`, който представя списък от числа
6. Дефинирайте функциите:
- `ihead :: IntList -> Int`, която връща първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
- `itail :: IntList -> IntList`, която връща елементите след първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
7. Дефинирайте функцията `isum :: IntList -> Int`, която сумира списъка от числа
8. Дефинирайте функцията `iseq :: Int -> Int -> IntList`, такава че `iseq a b` връща списък с числата `a, a + 1, a + 2, ..., b`
9. Дефинирайте функцията `imap :: (Int -> Int) -> IntList -> IntList`, такава че `imap f l` връща нов списък, чийто елементи са резултатите от прилагането на `f` върху елементите на `l`
10. Дефинирайте функцията `ifilter :: (Int -> Bool) -> IntList -> IntList`, такава че `ifilter f l` връща нов списък, съдържащ само тези елементи на `l`, за които `f` връща `True`
11. Дефинирайте функцията `primeFacs :: Int -> Int -> IntList`, използвайки функции, дефинирани досега, такава че `primeFacs a b` връща списък от тези числа `x` между `a` и `b`, такива че `x! + 1` е просто

## Параметрични типове
12. Дефинирайте тип `List a`, който представя списък от елементи от тип `a`
13. Дефинирайте функциите:
- `lhead :: List a -> a`, която връща първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
- `ltail :: List a -> List a`, която връща елементите след първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
- `safeHead :: List a -> Maybe a`, ко
