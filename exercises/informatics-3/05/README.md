## Haskell

- Типизиран (много силно)
- Чисто функционален
- Компилиран
- От светлата страна на програмирането

## Скучни задачи (аритметика)
Да напишем заедно следните функции:

1. `fact :: Int -> Int`, такава че `factorial n` връща n!
2. `fib :: Int -> Int`, такава че `fib n` връща n-тото число на Фибоначи

Напишете следните функции:

3. `isPrime :: Int -> Bool`, която проверява дали число е просто
4. `gcd' :: Int -> Int -> Int`, която намира най-големият общ делител на 2 числа

## Не толкова скучни задачи

5. Дефинирайте тип `IntList`, който представя списък от числа
6. Дефинирайте функциите:
- `ihead :: IntList -> Int`, която връща първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
- `itail :: IntList -> IntList`, която връща елементите след първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
7. Дефинирайте функцията `isum :: IntList -> Int`, която сумира списъка от числа
8. Дефинирайте функцията `iseq :: Int -> Int -> IntList`, такава че `iseq a b` връща списък с числата `a, a + 1, a + 2, ..., b`
9. Дефинирайте функцията `imap :: (Int -> Int) -> IntList -> IntList`, такава че `imap f l` връща нов списък, чийто елементи са резултатите от прилагането на `f` върху елементите на `l`
10. Дефинирайте функцията `ifilter :: (Int -> Bool) -> IntList -> IntList`, такава че `ifilter f l` връща нов списък, съдържащ само тези елементи на `l`, за които `f` връща `True`
11. Дефинирайте функцията `primeFacs :: Int -> Int -> IntList`, използвайки функции, дефинирани досега, такава че `primeFacs a b` връща списък от тези числа `x` между `a` и `b`, такива че `x! + 1` е просто

## Параметрични типове

12. Дефинирайте тип `List a`, който представя списък от елементи от тип `a`
13. Дефинирайте функциите:
- `lhead :: List a -> a`, която връща първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
- `ltail :: List a -> List a`, която връща елементите след първия елемент (ако списъкът е непразен) или `undefined`, ако списъкът е празен
- `safeHead :: List a -> Maybe a`, която връща `Just x`, където x е първият елемент на списъка, ако той е непразен, или `Nothing`, ако той е празен
- `safeTail :: List a -> Maybe (List a)`, която връща `Just lt`, където `lt` е списък от елементите след първия елемент на списъка, ако той е непразен, или `Nothing`, ако той е празен
14. Дефинирайте следните функции, аналогични на функции в предния раздел (може да използвате copy-paste и после да редактирате):
- `lsum :: List Int -> Int`
- `lseq :: Int -> Int -> List Int`
- `lmap :: (a -> b) -> List a -> List b`
- `lfilter :: (a -> Bool) -> List a -> List a`
- `primeFacs' :: Int -> Int -> List Int`
