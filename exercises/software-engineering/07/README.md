Упражнение 7
============

Асоциативни списъци
-------------------
За решаването на задачите използвайте основните процедури за работа с
асоциативни списъци, дефинирани в [association-list.scm](association-list.scm).

1. Да се дефинира процедура `(run-length-encode l)`, която кодира списъка `l` в
асоциативен списък - списък от наредени двойки `(<ключ> . <стойност>)`, където
`<ключ>`-ът e пореден елемент от списъка `l`, а `<стойност>`-та е броят на
последователните повторения на `<ключ>`.

   ```scheme
   (run-length-encode '(8 7 7 2 2 2 2 3 3 2)) ; -> ((8 . 1) (7 . 2) (2 . 4) (3 . 2) (2 . 1))
   ```

2. Да се дефинира процедура `(run-length-decode code)`, която възстановява
списъка, който е кодиран чрез `run-length-encode` от предната задача в
асоциативния списък `code`.

   ```scheme
   (run-length-decode '((1 . 2) (3 . 4) (5 . 2))) ; -> (1 1 3 3 3 3 5 5)
   ```

3. Да се дефинира процедура `(histogram l)`, която връща хистограма на
срещанията на всички елементи в `l` под формата на асоциативен списък.

   ```scheme
   (histogram '(8 7 1 7 8 2 2 8 2 7 8 1)) ; -> ((8 . 4) (7 . 3) (1 . 2) (2 . 3))
   ```

4. Да се дефинира процедура `(group-by f l)`, която връща асоциативен списък, в
който ключовете са стойностите на процедурата `f` след прилагането ѝ върху
елементи от списъка `l`, а срещу ключовете стои списък от елементите, за които
процедурата `f` дава стойността от ключа.

   ```scheme
   (group-by (lambda (x) (remainder x 3))
             '(0 1 2 3 4 5 6 7 8)) ; -> ((0 0 3 6) (1 1 4 7) (2 2 5 8))
   ```

Графи
-----
За решаването на задачите използвайте основните процедури за работа с
графи, дефинирани в [graph.scm](graph.scm).

1. Дефинирайте процедура `(degree v g)`, която връща степента на върха `v` в
ориентирания граф `g`.

2. Дефинирайте процедура `(edges g)`, която връща списък с всички ребра на
ориентирания граф `g`.

3. Дефинирайте процедура `(symmetric? g)`, която проверява дали ориентираният
граф `g` е симетричен.

4. Дефинирайте процедура `(invert g)`, която инвертира ориентирания граф `g`,
тоест връща нов граф, който има ребра от вида (v, u) за всяко ребро (u, v) от
`g`.

5. Дефинирайте процедура `(path? u v g)`, която проверява дали има път между
върховете `u` и `v` в ориентирания граф `g`.

6. Дефинирайте процедура `(acyclic? g)`, която проверява дали ориентираният граф
`g` е ацикличен.
