# Упражнение 11 – модула Prelude

Може да търсим функциите от Prelude и много други модули тук:
https://hoogle.haskell.org

Искаме да скрием следните стандартни функции, така че да ги имплементираме.
```hs
import Prelude hiding (sum, length, (++), (!!), maximum, elem, reverse,
                       take, drop, concat, zipWith, takeWhile, dropWhile)
```

Напишете типови декларации и дефиниции на следните функции от Prelude:
 1. `sum` – сумира всички елементи на списък от числа
 2. `length` – намира дължина на списък
 3. `(++)` – append-ва един списък след друг
    ```hs
    [1,2,3,4] ++ [5,6] --> [1,2,3,4,5,6]
    ```
 4. `(!!)` – връща n-тия елемент на списък, същото като list-ref в Scheme
    ```hs
    [0,1,2,3,4] !! 0 --> 0
    [0,1,2,3,4] !! 3 --> 3
    ```
 5. `isSorted` - проверява дали списък от числа е сортиран
    ```hs
    isSorted [1,2,3,4] --> True
    isSorted [1,2,4,3] --> False
    ```
 6. `maximum` – намира най-големия елемент в списък
    ```hs
    maximum [1,2,3,4] --> 4
    ```
 7. `elem` – намира дали елемент се съдържа в списък
    ```hs
    elem 'y' "xyz" --> True
    'y' `elem` "XYZ" --> False
    ```
 8. `reverse` – обръща реда на елементите на списък
    ```hs
    reverse "rekontra" --> "artnoker"
    ```
 9. `isPrefix` – приема два списъка и връща дали първия е префикс на втория
    ```hs
    isPrefix [1,2,3] [1,2,3,4,5] --> True
    ```
 10. `take` – взима първите `n` елемента от даден списък
     ```hs
     take 10 [1..] --> [1,2,3,4,5,6,7,8,9,10]
     ```
 11. `drop` - премахва първите `n` елемента от даден списък
     ```hs
     drop 11 [1..15] --> [11,12,13,14,15]
     ```
 12. `zip` - по дадени два списъка връща списък от наредени двойки с елементите им
     ```hs
     zip [1,2,3] [4,5,6,7] --> [(1,4),(2,5),(3,6)]
     ```
 13. `concat` – по списък от списъци прави списък, тоест слепя всички елементи на списъка
     ```hs
     concat [[1,2,3],[4],[5,6]] --> [1,2,3,4,5,6]
     ```
 14. `zipWith` – по два списъка образува нов, извиквайки функция над всеки от елементите
     ```hs
     zipWith (,) [1,2,3] [4,5,6,7] --> [(1,4),(2,5),(3,6)]
     zipWith (+) [1,2,3] [4,5,6,7] --> [5,7,9]
     ```
 15. `takeWhile` – приема предикат и списък `xs` и връща най-дългия префикс на `xs`, за чийто всички елементи на предиката връщат истина
     ```hs
     takeWhile (>10) [11,12,20,2,3,11,15] --> [11,12,20]
     ```
 16. `dropWhile` – еквивалента на `takeWhile`, който премахва вместо да взима
     ```hs
     dropWhile (>10) [11,12,20,2,3,11,15] --> [2,3,11,15]
     ```

<hr />

 17. `maxRepeated` – по списък от цели числа връща дължината на най-дългия подсписък с еднакви числа
     ```hs
     maxRepeated [1,1,1,2,3,3,3,1,4,2,2,2,2,1,1,1] --> 4
     ```
     > Бонус: направете `maxRepeated` да работи със списъци от каквито и да е елементи, който могат да се сравняват. Примерно:
     ```hs
     maxRepeated "kakvokazvashh" --> 2
     ```
 18. `histogram` – за всяка уникална стойност от даден списък връща списък от наредени двойки от вида `(<стойност>, <общ брой срещания>)`
     ```hs
     histogram [1,1,2,3,3,3,4,2,2,2,1,1] --> [(1,4),(2,4),(3,3),(4,1)]
     histogram "kakkakvokoko" --> [('k',6),('a',2),('v',1),('o',3)]
     ```
 19. `permutations` – връща списъка от всички пермутации на даден списък
     ```hs
     permutations [1,2,3] --> [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
     ```
     > `permutations` и други полезни функции се намират в модула `Data.List`
 20. `scanr` и `scanl` – по дадени двуместна операция `op`, начална стойност `nv` и списък `xs`, връщат списъка от извикванията съответно на `foldr` и `foldl` със `op`, `nv` и всичките [съответно суфикси или префикси] на `xs`
     ```hs
     scanl :: (b -> a -> b) -> b -> [a] -> [b]

     scanl (+) 0 [1..5] --> [0,1,3,6,10,15]
     scanr (+) 0 [1..5] --> [15,14,12,9,5,0]
     ```
