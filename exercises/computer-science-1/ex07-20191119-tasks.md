# Упражнение 7 - Структури от данни

[код от упражнението](ex07-20191119-solutions.rkt)

За удобство и консистентност отново ще използваме следните "стандартни" функции за работа с дървета и графи:
```
(define (tree? t)
  (or (null? t)
      (and (list? t)
           (= (length t) 3))
           (tree? (cadr t))
           (tree? (caddr t))))
(define empty-tree '())
(define (make-tree root left right) (list root left right))      ; не искаме просто (define make-tree list) - защо?
(define (make-leaf root) (make-tree root empty-tree empty-tree)) ; за удобство
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)
```
```
(define (vertices g) (map car g))

(define (search p? l)
  (and (not (null? l))
       (or (p? (car l))
           (search p? (cdr l)))))

(define (all? p? l)
  (not (search (lambda (x) (not (p? x))) l)))

(define (children u g) (cdr (assv u g)))

(define (edge? u v g) (memv v (children u g)))
```
### Зад.1.
Да се напише функция `(bst-insert val t)`, която вмъква стойността `val` в двоичното наредено дърво `t`.
### Зад.2.
Да се напише функция `(valid-bst? t)`, която проверява дали дървото `t` е валидно двоично наредено дърво.
### Зад.3.
Да се напише функция `(interval-tree t)`, която преобразува двоично дърво от числа в ново дърво със същата структура, в което стойността във всеки възел е заменена с наредена двойка, представляваща най-малкия интервал, съдържащ всички стойности в съответното поддърво.
### Зад.3½*.
Функцията да работи за време `O(n)` в най-лошия случай.
### Зад.4.
Да се напише функция `(chinese? g)`, която за даден граф `g`
проверява дали за него е изпълнен китайският закон: “даден възел може да има повече от един наследник само ако е той е единствен наследник на родителя си”
### Зад.5.
Път от корен до възел в двоично дърво кодираме с поредица от цифри 0 и 1, която започва с цифрата 1, а за всяка следваща цифра 0 означава завиване по левия клон, а 1 — по десния. Да се напише функция `(same-as-code t)`, която в двоично дърво от числа връща списък от тези числа `x`, за които стойността на двоичното число, кодиращо пътя от корена до възела на `x`, съвпада с `x`.
### Зад.6.
Два реда на матрица наричаме “линейно (не)зависими”, ако елементите на единия ред (не) могат да се получат при умножение на елементите на другия ред с едно и също число. Да се дефинира функция `(dependent l1 l2)`, която проверява дали списъците от числа с еднаква ненулева дължина `l1` и `l2` са линейно зависими.
```
(dependent '(2 6 4) '(3 9 6)) → True
(dependent '(1 2) '(3 4)) → False
```
### Зад.6½.
“Псевдоранг” на матрица наричаме максималния брой нейни редове, които два по два са линейно независими. Да се дефинира функция pseudorank m, която пресмята псевдоранга на дадена матрица m от положителни цели числа.

_Упътване 1:_ псевдорангът на матрица, чиито всички n реда са независими, е n.

_Упътване 2:_ псевдорангът на матрица се запазва при премахване на произволен неин ред, който е линейно зависим с някой друг неин ред.
```
(pseudorank '((2 6 4) (6 3 6) (3 9 6) (8 4 8) (1 3 2))) → 2
```
### Зад.7.
Да се напише функция `(sub-matrix i1 j1 i2 j2 m)`, която намира подматрицата на `m` със зададени горен ляв и долен десен ъгъл `(i1,j1)` и `(i2,j2)`, съответно.
### Зад.7⅓.
Дадена е матрица `m` от числа и списък `ps` от едноместни числови предикати. Да се напише функция `(find-submatrix ps m)`, която намира най-голямата квадратна подматрица на `m` такава, че всеки неин елемент удовлетворява поне един от предикатите в списъка `ps`.
```
(findSubmatrix
  (list even? (lambda (x) (> x 3)))
  '((1 2 3) (4 5 6) (7 8 9)))
→ ((4 5) (7 8))
```
### Зад.7⅔*.
Допълнение към горната задача: Ако има няколко еднакви по размер подматрици, отговарящи на условието, да се върне тази от тях, която е разположена възможно най-горе и възможно най-вляво.
### Зад.8.
Даден е граф `g`, представен със списък от наследници и връх `u` в графа. Да се напише функция `(max-path u g)`, която намира най-дългия ацикличен път в графа, започващ от този връх.
