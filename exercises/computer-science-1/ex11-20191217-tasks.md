# Упражнение 11 - Списъци и ламбди

[код от упражнението](ex11-20191217-solutions.rkt)

### Зад.1.
За тази задача ще представяме множествата като наредени списъци от своите елементи (значи те трябва да могат да бъдат сравнявани с == и < и да се срещат точно по веднъж). Да се напишат функции `setUnion`, `setIntersect` и `setDiff`, които намират съответно обединението, сечението и разликата на две множества:
```haskell
setUnion [1,2,3,5] [2,4,5,6,7] -> [1,2,3,4,5,6,7]
setIntersect [1,2,3,5] [2,4,5,6,7] -> [2,5]
setDiff [1,2,3,5] [2,4,5,6,7] -> [1,3]
setDiff [2,4,5,6,7] [1,2,3,5] -> [4,6,7]
```
### Зад.2.
Да се напише функция `compress`, която по списък от стойности връща списък от наредени двойки от вида (<стойност>, <брой последователни срещания>):
```haskell
compress [1,1,2,3,3,3,4,2,2,2,2,1] -> [(1,2),(2,1),(3,3),(4,1),(2,4),(1,1)]
compress "abba" -> [('a',1),('b',2),('a',1)]
```
### Зад.3.
Да се напише функция `maxRepeated`, която по списък от стойности връща дължината на най-дългия подсписък, съставен от еднакви стойности:
```haskell
maxRepeated [1,1,2,3,3,3,4,2,2,2,2,1,1] -> 4
```
### Зад.4.
Нека е дадена квадратна матрица от числа. Под “Гаусова елиминация” ще разбираме операцията, при която се избира първият ред отгоре надолу, в който първият елемент е ненулев, и към всеки друг ред на матрицата прибавяме избрания ред, умножен по такъв коефициент, че числата в първия стълб на тези редове да станат равни на нула:
```haskell
[[ 0,3,5,0],     [[0, 3,5,0],
 [ 1,5,2,1],  ->  [1, 5,2,1],
 [ 2,3,8,4],      [0,-7,4,2], -- получено от (ред2 * (-2)) + ред2
 [-2,0,4,5]]      [0,10,8,7]] -- получено от (ред2 * 2) + ред3
```
Напишете функция `rowReduce`, която извършва тази операция. Можете да допуснете, че в първия стълб на матрицата има поне един ненулев елемент.
### Зад.5*.
Напишете функция, която изчислява детерминантата на дадена квадратна матрица.
### Зад.6.
Напишете функция `crossOut`, която по дадена матрица от числа `m` с размери M\*N генерира всички M\*N на брой матрици, които могат да се получат от `m` със задраскване на някой ред и някой стълб. Редът на върнатите матрици няма значение.
```haskell
cross-out [[1,2,3,4],     [ [[6,7,8],[0,1,2]], [[5,7,8],[9,1,2]], [[5,6,8],[9,0,2]],
           [5,6,7,8],  ->   [[5,6,7],[9,0,1]], [[2,3,4],[0,1,2]], ...
           [9,0,1,2]]     -- и още 7 малки матрици
```
### Зад.7.
Да се напише функция `specialSort`, която приема като параметър списък от списъци и го сортира относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, да се избира най-големия от тях:
```haskell
specialSort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
  -> ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
-- в случая най-често срещаните елементи са съответно 'a', 'e', 'e', 'g', 'm', 'o', 'z'
-- наредбата не е уникална - няма проблем с това, нямаме изисквания за стабилност
```
